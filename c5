# =============================================================================
# DEBUGGED MP3 TRANSCRIPTION PIPELINE - FIXED VERSION
# Addresses common installation and configuration issues
# =============================================================================

# CELL 1: Restart Environment
%restart_python

# CELL 2: Install Packages with Error Handling
import subprocess
import sys

def install_package(package):
    try:
        subprocess.check_call([sys.executable, "-m", "pip", "install", package])
        print(f"‚úÖ Successfully installed {package}")
    except Exception as e:
        print(f"‚ùå Failed to install {package}: {e}")

# Install required packages
packages = [
    "azure-cognitiveservices-speech==1.34.0",
    "azure-identity==1.15.0", 
    "librosa==0.10.1"
]

for package in packages:
    install_package(package)

print("üì¶ Package installation completed")

# CELL 3: Import Libraries with Error Handling
try:
    import os
    import time
    import threading
    import warnings
    from pathlib import Path
    import pandas as pd
    from pyspark.sql import SparkSession
    from datetime import datetime
    
    print("‚úÖ Basic imports successful")
    
    # Import Azure libraries with error handling
    import azure.cognitiveservices.speech as speechsdk
    from azure.identity import ClientSecretCredential
    print("‚úÖ Azure libraries imported successfully")
    
    # Import librosa with error handling
    import librosa
    print("‚úÖ Librosa imported successfully")
    
    # Suppress warnings
    warnings.filterwarnings('ignore')
    print("‚úÖ SUCCESS: All libraries loaded successfully")
    
except ImportError as e:
    print(f"‚ùå Import error: {e}")
    print("Please restart Python and try again")
except Exception as e:
    print(f"‚ùå Unexpected error: {e}")

# CELL 4: Azure Configuration with Validation
print("üîß Setting up Azure configuration...")

AZURE_ENDPOINT = "https://dahiwade-openai-0397ab9d9c6b4f1fae9f4b4d81.cognitiveservices.azure.com/"
TENANT_ID = "1f656ea2-a5d8-4b93-8dc6-4fd7e59e0d5a"
CLIENT_ID = "895f21a2-183c-4e35-80a3-e3c9de56e45e"

try:
    CLIENT_SECRET = dbutils.secrets.get(scope="databricksScope", key="svc-b-a1-d-930710-ana-aadappClientapi")
    if CLIENT_SECRET:
        print("‚úÖ SUCCESS: Azure credentials retrieved")
    else:
        print("‚ùå ERROR: Empty credentials")
except Exception as e:
    print(f"‚ùå ERROR: Failed to get credentials: {e}")

# CELL 5: Create Azure Speech Config with Better Error Handling
def create_azure_speech_config():
    """Create Azure Speech Services configuration with detailed error handling"""
    try:
        print("üîÑ Creating Azure credential...")
        credential = ClientSecretCredential(
            tenant_id=TENANT_ID,
            client_id=CLIENT_ID,
            client_secret=CLIENT_SECRET
        )
        
        print("üîÑ Getting access token...")
        token = credential.get_token("https://cognitiveservices.azure.com/.default").token
        
        print("üîÑ Creating speech config...")
        speech_config = speechsdk.SpeechConfig(endpoint=AZURE_ENDPOINT)
        speech_config.authorization_token = token
        speech_config.speech_recognition_language = "en-US"
        
        print("‚úÖ SUCCESS: Azure Speech Services configuration created")
        return speech_config
        
    except Exception as e:
        print(f"‚ùå ERROR: Failed to create speech config")
        print(f"Error details: {str(e)}")
        print("Please check your Azure credentials and endpoint")
        return None

# Initialize speech config with error checking
speech_config = create_azure_speech_config()

if speech_config is None:
    print("‚ùå CRITICAL ERROR: Cannot proceed without speech config")
else:
    print("‚úÖ Speech config ready for use")

# CELL 6: MP3 Processing Functions with Better Error Handling
def get_mp3_duration(mp3_file_path):
    """Get MP3 duration with fallback options"""
    try:
        duration = librosa.get_duration(path=mp3_file_path)
        print(f"üìè Duration: {duration:.1f} seconds")
        return duration
    except Exception as e:
        print(f"‚ö†Ô∏è  Warning: Could not get duration using librosa: {e}")
        try:
            # Fallback: estimate from file size
            file_size = os.path.getsize(mp3_file_path)
            estimated_duration = file_size / 32000  # Rough estimate
            print(f"üìè Estimated duration: {estimated_duration:.1f} seconds")
            return estimated_duration
        except:
            print("‚ö†Ô∏è  Using default duration of 60 seconds")
            return 60.0

def transcribe_mp3_directly(mp3_file_path):
    """Transcribe MP3 with comprehensive error handling"""
    try:
        if speech_config is None:
            raise Exception("Speech config not initialized")
            
        print("üé§ Creating audio configuration...")
        audio_config = speechsdk.AudioConfig(filename=mp3_file_path)
        
        print("üé§ Creating speech recognizer...")
        recognizer = speechsdk.SpeechRecognizer(
            speech_config=speech_config, 
            audio_config=audio_config
        )
        
        # Storage for transcript parts
        transcript_parts = []
        done = threading.Event()
        error_occurred = False
        error_message = ""

        def on_recognized(evt):
            if evt.result.text:
                transcript_parts.append(evt.result.text)
                print(f"üìù Recognized: {evt.result.text[:50]}...")

        def on_session_stopped(evt):
            print("‚úÖ Transcription session completed")
            done.set()

        def on_canceled(evt):
            nonlocal error_occurred, error_message
            error_occurred = True
            error_message = f"Transcription canceled: {evt.reason}"
            if evt.reason == speechsdk.CancellationReason.Error:
                error_message += f" - Error: {evt.error_details}"
            print(f"‚ùå {error_message}")
            done.set()

        # Connect event handlers
        recognizer.recognized.connect(on_recognized)
        recognizer.session_stopped.connect(on_session_stopped)
        recognizer.canceled.connect(on_canceled)

        # Start transcription
        print("üé§ Starting transcription...")
        recognizer.start_continuous_recognition()
        
        # Wait for completion (with timeout)
        if done.wait(timeout=300):  # 5 minute timeout
            recognizer.stop_continuous_recognition()
        else:
            recognizer.stop_continuous_recognition()
            raise Exception("Transcription timeout after 5 minutes")

        # Check for errors
        if error_occurred:
            raise Exception(error_message)

        # Combine transcript parts
        full_transcript = " ".join(transcript_parts).strip()
        if not full_transcript:
            raise Exception("No speech detected in audio file")

        print(f"‚úÖ Transcription completed: {len(full_transcript)} characters")
        return full_transcript

    except Exception as e:
        print(f"‚ùå Transcription failed: {str(e)}")
        raise

# CELL 7: Main Processing Function
def process_mp3_file(mp3_file_path):
    """Complete MP3 processing pipeline with comprehensive error handling"""
    start_time = time.time()

    try:
        print("üöÄ MP3 TRANSCRIPTION PIPELINE STARTED")
        print("=" * 50)

        # Step 1: Validate input file
        if not os.path.exists(mp3_file_path):
            raise Exception(f"MP3 file not found: {mp3_file_path}")
        if not mp3_file_path.lower().endswith('.mp3'):
            raise Exception("File must be in MP3 format")

        # Step 2: Extract file info
        file_name = Path(mp3_file_path).name
        file_size = os.path.getsize(mp3_file_path) / (1024 * 1024)  # MB

        print(f"üìÅ File: {file_name}")
        print(f"üìä Size: {file_size:.2f} MB")

        # Step 3: Get MP3 duration
        print("\nüìè Getting audio duration...")
        duration = get_mp3_duration(mp3_file_path)

        # Step 4: Transcribe MP3
        print("\nüéØ Starting transcription...")
        transcript = transcribe_mp3_directly(mp3_file_path)

        # Step 5: Prepare data
        print("\nüíæ Preparing data...")
        processing_time = time.time() - start_time
        
        data = [[
            file_name,
            transcript,
            len(transcript),
            round(duration, 2),
            round(file_size, 2),
            round(processing_time, 2),
            datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        ]]
        
        columns = [
            "file_name", "transcript", "transcript_length", 
            "duration_seconds", "file_size_mb", "processing_time_seconds", 
            "timestamp"
        ]
        
        # Create DataFrame
        pandas_df = pd.DataFrame(data, columns=columns)
        spark_df = spark.createDataFrame(pandas_df)

        print("‚úÖ DataFrame created successfully")
        return spark_df

    except Exception as e:
        print(f"‚ùå Pipeline failed: {str(e)}")
        return None

# CELL 8: Execute Pipeline with Complete Error Handling
try:
    # Initialize Spark session
    spark = SparkSession.builder.getOrCreate()
    print("‚úÖ Spark session initialized")

    # Verify speech config
    if speech_config is None:
        print("‚ùå ERROR: Speech config not available. Cannot proceed.")
        print("Please check your Azure credentials and run cells 4-5 again.")
    else:
        # Set your MP3 file path
        mp3_file_path = "/Workspace/Users/anuj.b.s@mughalvaren.com/sample-ppt/audio/presentation_script/1_user_say/mygov_1.mp3"

        # Validate file exists
        if not os.path.exists(mp3_file_path):
            print(f"‚ùå ERROR: File not found: {mp3_file_path}")
            print("Please check your file path and try again.")
        else:
            print(f"üéµ Processing: {Path(mp3_file_path).name}")
            
            # Run the pipeline
            result = process_mp3_file(mp3_file_path)

            if result is not None:
                print("\nüìä DISPLAYING RESULTS:")
                display(result)

                # Save to catalog
                try:
                    result.write.mode("append").saveAsTable("audio_transcripts")
                    print("‚úÖ Data saved to audio_transcripts table")
                except Exception as save_error:
                    print(f"‚ùå Failed to save to catalog: {save_error}")

                print("üéâ MP3 transcript pipeline completed successfully!")
            else:
                print("‚ùå Pipeline failed - check error messages above")

except Exception as e:
    print(f"‚ùå Critical error: {str(e)}")
    print("Please check all configurations and try again")